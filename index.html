<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Saudi Arabia Incident Map</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
<style>
  html, body, #map {
    height: 100%;
    margin: 0;
    padding: 0;
  }
  #map, #map * {
    cursor: default !important;
  }
</style>
</head>
<body>
<div id="map"></div>

<!-- Libraries -->
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script src="https://unpkg.com/supercluster@8.0.1/dist/supercluster.min.js"></script>

<script>
  const map = L.map('map', { preferCanvas: true }).setView([24.7136, 46.6753], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);

  const clusterIndex = supercluster({ radius: 60, maxZoom: 17 });
  const markersLayer = L.layerGroup().addTo(map);

  let allPoints = [];
  let selectedState = null;

  const BLUE = "#007bff";
  const YELLOW = "#ffcc00";

  function renderClusters() {
    markersLayer.clearLayers();

    const bounds = map.getBounds();
    const zoom = map.getZoom();
    const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
    const clusters = clusterIndex.getClusters(bbox, zoom);

    clusters.forEach(cluster => {
      const [lng, lat] = cluster.geometry.coordinates;

      if (cluster.properties.cluster) {
        // Cluster point
        const count = cluster.properties.point_count;
        const size = Math.min(40, 10 + Math.log(count) * 5);
        const circle = L.circleMarker([lat, lng], {
          radius: size / 2,
          fillColor: "#3388ff",
          color: "#ffffff",
          weight: 1,
          fillOpacity: 0.8,
          interactive: false
        }).bindTooltip(`${count} points`);
        circle.on("click", () => map.setView([lat, lng], zoom + 2));
        markersLayer.addLayer(circle);
      } else {
        const { state, count } = cluster.properties;
        const isSelected = state === selectedState;
        const marker = L.circleMarker([lat, lng], {
          radius: 6,
          fillColor: isSelected ? YELLOW : BLUE,
          color: "#fff",
          weight: 1,
          fillOpacity: 1
        });
        marker.on("click", () => handleMarkerClick(state, lat, lng, count));
        markersLayer.addLayer(marker);
      }
    });
  }

  function handleMarkerClick(state, lat, lng, count) {
    if (selectedState === state) {
      selectedState = null;
      window.parent.postMessage({
        type: "mapClick",
        state: "All",
        lat: "All",
        long: "All",
        label: "All",
        count: "All"
      }, "*");
    } else {
      selectedState = state;
      window.parent.postMessage({
        type: "mapClick",
        state: state,
        lat: lat,
        long: lng,
        label: state,
        count: count
      }, "*");
    }
    renderClusters();
  }

  // ðŸ”¹ Grafana â†’ HTML panel data listener
  window.addEventListener("message", (event) => {
    const payload = event.data;
    if (!payload || !payload.series) return;

    try {
      const rows = payload.series[0].fields;
      const state = rows.find(f => f.name.toLowerCase().includes("state"));
      const lat = rows.find(f => f.name.toLowerCase().includes("lat"));
      const long = rows.find(f => f.name.toLowerCase().includes("long"));
      const count = rows.find(f => f.name.toLowerCase().includes("count"));

      const len = state.values.length;
      allPoints = [];

      for (let i = 0; i < len; i++) {
        const s = state.values[i];
        const la = parseFloat(lat.values[i]);
        const lo = parseFloat(long.values[i]);
        const c = count.values[i];

        if (!isNaN(la) && !isNaN(lo)) {
          allPoints.push({
            type: "Feature",
            geometry: { type: "Point", coordinates: [lo, la] },
            properties: { state: s, count: c }
          });
        }
      }

      if (allPoints.length > 0) {
        clusterIndex.load(allPoints);
        const latLngs = allPoints.map(p => [p.geometry.coordinates[1], p.geometry.coordinates[0]]);
        map.fitBounds(latLngs, { padding: [30, 30] });
      }
      renderClusters();
      console.log(`âœ… Loaded ${allPoints.length} points from query`);
    } catch (e) {
      console.error("Data parsing error:", e);
    }
  });

  map.on("moveend", renderClusters);
  console.log("ðŸš€ Saudi Arabia Map Ready for Dynamic Query Data");
</script>
</body>
</html>
