<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Incident Map (Optimized & Clean)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
<style>
  html, body, #map {
    height: 100%;
    margin: 0;
    padding: 0;
    cursor: default;
  }

  /* Remove "hand" cursor on markers */
  .leaflet-marker-icon {
    cursor: default !important;
  }
</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<script>
  // === MAP INITIALIZATION ===
  const map = L.map('map', { preferCanvas: true }).setView([24.7136, 46.6753], 6);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);

  // === CLUSTER GROUP ===
  const markerCluster = L.markerClusterGroup({
    disableClusteringAtZoom: 9,
    chunkedLoading: true,
    chunkDelay: 25,
    chunkInterval: 200
  });
  map.addLayer(markerCluster);

  // === ICONS ===
  const blueIcon = L.icon({
    iconUrl: "https://maps.google.com/mapfiles/ms/icons/blue-dot.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32]
  });

  const yellowIcon = L.icon({
    iconUrl: "https://maps.google.com/mapfiles/ms/icons/yellow-dot.png",
    iconSize: [32, 32],
    iconAnchor: [16, 32]
  });

  // === STATE MANAGEMENT ===
  let markerDataMap = new Map();
  let currentDataHash = null;
  let selectedMarker = null;
  let initialViewSet = false;

  // === HASH GENERATOR ===
  function generateDataHash(data) {
    if (!data || !data.lat) return null;
    return data.lat.length + "_" + data.lat[0] + "_" + data.long[0];
  }

  // === BATCHED MARKER ADDING ===
  function addMarkersInBatches(data, latLngs) {
    const batchSize = 500;
    let index = 0;

    function processBatch() {
      const end = Math.min(index + batchSize, data.lat.length);

      for (let i = index; i < end; i++) {
        const lat = parseFloat(data.lat[i]);
        const lng = parseFloat(data.long[i]);
        if (isNaN(lat) || isNaN(lng)) continue;

        const label = decodeURIComponent(data.state[i]);
        const count = data.count[i];
        const markerId = `${lat}_${lng}`;

        const marker = L.marker([lat, lng], { icon: blueIcon });
        marker.bindPopup(`${label}<br>Count: ${count}`);
        markerDataMap.set(markerId, { state: data.state[i], lat, lng, label, count, marker });

        marker.on("click", () => handleMarkerClick(markerId));

        markerCluster.addLayer(marker);
        latLngs.push([lat, lng]);
      }

      index = end;
      if (index < data.lat.length) {
        requestAnimationFrame(processBatch);
      } else {
        console.log("âœ… All markers added!");
      }
    }

    requestAnimationFrame(processBatch);
  }

  // === MARKER CLICK HANDLER ===
  function handleMarkerClick(markerId) {
    const markerData = markerDataMap.get(markerId);
    const marker = markerData.marker;

    // Toggle between yellow and blue
    if (selectedMarker === marker) {
      marker.setIcon(blueIcon);
      selectedMarker = null;
      window.parent.postMessage({
        type: "mapVariableReset",
        LOCATIONNAME: "All",
        Latitude: "All",
        Longitude: "All"
      }, "*");
      return;
    }

    // Reset previous selection
    if (selectedMarker) selectedMarker.setIcon(blueIcon);

    // Highlight current marker
    marker.setIcon(yellowIcon);
    selectedMarker = marker;

    // Send update to parent
    window.parent.postMessage({
      type: "mapVariableUpdate",
      LOCATIONNAME: markerData.state,
      Latitude: markerData.lat,
      Longitude: markerData.lng
    }, "*");
  }

  // === HANDLE INCOMING DATA FROM GRAFANA ===
  window.addEventListener("message", (event) => {
    const data = event.data;
    if (!data || !data.lat || !data.long || !data.state) return;

    const newHash = generateDataHash(data);
    if (newHash === currentDataHash) return;
    currentDataHash = newHash;

    const currentCenter = map.getCenter();
    const currentZoom = map.getZoom();
    const shouldSetInitialView = !initialViewSet;

    markerCluster.clearLayers();
    markerDataMap.clear();
    selectedMarker = null;

    const latLngs = [];
    addMarkersInBatches(data, latLngs);

    // Adjust view only initially
    if (shouldSetInitialView && data.lat.length > 0) {
      const firstLat = parseFloat(data.lat[0]);
      const firstLng = parseFloat(data.long[0]);
      if (data.lat.length === 1) map.setView([firstLat, firstLng], 10);
      else map.fitBounds(latLngs, { padding: [30, 30] });
      initialViewSet = true;
    } else {
      map.setView(currentCenter, currentZoom, { animate: false });
    }
  });

  console.log("ðŸš€ Optimized map ready â€” waiting for Grafana data...");
</script>
</body>
</html>
