<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultra-Fast Incident Map</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
<style>
  html, body, #map {
    height: 100%;
    margin: 0;
    padding: 0;
  }

  /* âœ… Remove all hand/pointer cursors */
  #map,
  #map * {
    cursor: default !important;
  }
</style>
</head>
<body>
<div id="map"></div>

<!-- JS Libraries -->
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script src="https://unpkg.com/supercluster@8.0.1/dist/supercluster.min.js"></script>

<script>
  // === Initialize map ===
  const map = L.map('map', { preferCanvas: true, zoomControl: true })
    .setView([24.7136, 46.6753], 6);

  // === Base tile layer ===
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors',
    maxZoom: 18
  }).addTo(map);

  // === Supercluster ===
  let clusterIndex = supercluster({
    radius: 60,
    maxZoom: 17
  });

  // === Layers & states ===
  const markersLayer = L.layerGroup().addTo(map);
  let allPoints = [];
  let selectedState = null;

  const BLUE = "#007bff";
  const YELLOW = "#ffcc00";

  // === Render clusters and individual markers ===
  function renderClusters() {
    markersLayer.clearLayers();

    const bounds = map.getBounds();
    const zoom = map.getZoom();
    const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
    const clusters = clusterIndex.getClusters(bbox, zoom);

    clusters.forEach(cluster => {
      const [lng, lat] = cluster.geometry.coordinates;

      if (cluster.properties.cluster) {
        // Cluster node
        const count = cluster.properties.point_count;
        const size = Math.min(40, 10 + (Math.log(count) * 5));

        const circle = L.circleMarker([lat, lng], {
          radius: size / 2,
          fillColor: "#3388ff",
          color: "#ffffff",
          weight: 1,
          fillOpacity: 0.8,
          interactive: false // âœ… no cursor or interactivity
        }).bindTooltip(`${count} points`);

        circle.on("click", () => map.setView([lat, lng], zoom + 2));
        markersLayer.addLayer(circle);
      } else {
        // Individual point
        const { state } = cluster.properties;
        const isSelected = (state === selectedState);

        const marker = L.circleMarker([lat, lng], {
          radius: 6,
          fillColor: isSelected ? YELLOW : BLUE,
          color: "#fff",
          weight: 1,
          fillOpacity: 1
        });

        marker.on("click", () => handleMarkerClick(state, lat, lng));
        markersLayer.addLayer(marker);
      }
    });
  }

  // === Handle click: toggle color + update/reset variable ===
  function handleMarkerClick(state, lat, lng) {
    if (selectedState === state) {
      // Deselect â†’ back to blue
      selectedState = null;
      window.parent.postMessage({
        type: "mapVariableReset",
        LOCATIONNAME: "All",
        Latitude: "All",
        Longitude: "All"
      }, "*");
    } else {
      // Select â†’ turn yellow
      selectedState = state;
      window.parent.postMessage({
        type: "mapVariableUpdate",
        LOCATIONNAME: state,
        Latitude: lat,
        Longitude: lng
      }, "*");
    }

    renderClusters(); // redraw with updated colors
  }

  // === Handle incoming Grafana data ===
  window.addEventListener("message", (event) => {
    const data = event.data;
    if (!data || !data.lat || !data.long || !data.state) return;

    // Prepare GeoJSON features
    allPoints = data.lat.map((lat, i) => ({
      type: "Feature",
      geometry: { type: "Point", coordinates: [parseFloat(data.long[i]), parseFloat(lat)] },
      properties: {
        state: decodeURIComponent(data.state[i]),
        count: data.count[i]
      }
    }));

    clusterIndex.load(allPoints);

    // Fit map once on initial load
    if (allPoints.length > 0) {
      const latLngs = allPoints.map(p => [p.geometry.coordinates[1], p.geometry.coordinates[0]]);
      map.fitBounds(latLngs, { padding: [30, 30] });
    }

    renderClusters();
  });

  // Update clusters when moving or zooming
  map.on("moveend", renderClusters);

  console.log("ðŸš€ Supercluster map ready â€” handles 100k+ points smoothly, no hand cursor");
</script>
</body>
</html>
